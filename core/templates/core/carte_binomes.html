{% extends 'core/base.html' %}
{% load static %}

{% block title %}Carte des Bin√¥mes - ESA Manager{% endblock %}

{% block extra_css %}
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
    #map { 
        height: 85vh; 
        width: 100%; 
        border-radius: 10px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    
    .filter-control {
        background: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        max-height: 550px;
        overflow-y: auto;
        max-width: 300px;
    }
    
    .filter-control h3 {
        margin: 0 0 15px 0;
        font-size: 16px;
        color: #333;
        border-bottom: 3px solid #0066cc;
        padding-bottom: 8px;
    }
    
    .filter-item {
        margin: 8px 0;
        display: flex;
        align-items: center;
        padding: 5px;
        border-radius: 4px;
    }
    
    .filter-item:hover {
        background: #f0f0f0;
    }
    
    .filter-item input[type="checkbox"] {
        margin-right: 10px;
        cursor: pointer;
        width: 18px;
        height: 18px;
    }
    
    .filter-item label {
        cursor: pointer;
        display: flex;
        align-items: center;
        flex: 1;
        font-size: 13px;
    }
    
    .filter-color {
        display: inline-block;
        width: 20px;
        height: 20px;
        margin-right: 8px;
        border: 1px solid #333;
        border-radius: 3px;
        flex-shrink: 0;
    }
    
    .info-popup {
        font-family: Arial, sans-serif;
        min-width: 200px;
    }
    
    .info-popup h4 {
        margin: 0 0 10px 0;
        color: #0066cc;
        font-size: 16px;
        border-bottom: 2px solid #0066cc;
        padding-bottom: 5px;
    }
    
    .info-popup p {
        margin: 6px 0;
        font-size: 13px;
    }
</style>
{% endblock %}

{% block content %}
<div class="row mb-3">
    <div class="col">
        <h2>
            <i class="bi bi-link-45deg"></i> Carte des bin√¥mes actifs
            <span class="badge bg-primary">{{ total_binomes }} bin√¥me(s)</span>
        </h2>
        <p class="text-muted">
            Visualisation des paires √©l√®ves-b√©n√©voles avec filtrage par arrondissement
        </p>
    </div>
</div>

<div id="map"></div>
{% endblock %}

{% block extra_js %}
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

<script>
// ============================================================================
// üé® CONFIGURATION
// ============================================================================

const markerColors = [
    '#FF5252', '#18FFFF', '#B2FF59', '#FFD740', '#E040FB',
    '#FFFF00', '#69F0AE', '#FF6E40', '#FF4081', '#40C4FF',
    '#7C4DFF', '#FFD740', '#B2FF59', '#FFAB40', '#E040FB', '#1DE9B6'
];

const colors = [
    '#FF1744', '#00E5FF', '#76FF03', '#FF9100', '#E040FB',
    '#FFEA00', '#00E676', '#FF3D00', '#F50057', '#00B0FF',
    '#651FFF', '#FFC400', '#64DD17', '#FF6D00', '#D500F9', '#00BFA5'
];
function getCouleurArrondissement(codePostalOuArrondissement) {
    if (!codePostalOuArrondissement) return '#666666';
    
    const str = codePostalOuArrondissement.toString();
    const match = str.match(/130(\d{2})/);
    
    if (match) {
        const numero = parseInt(match[1], 10);
        if (numero >= 1 && numero <= 16) {
            return markerColors[numero - 1];
        }
    }
    
    return '#666666';
}

// ============================================================================
// üó∫Ô∏è INITIALISATION DE LA CARTE
// ============================================================================

const map = L.map('map').setView([43.2965, 5.3698], 12);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '¬© OpenStreetMap contributors',
    maxZoom: 19
}).addTo(map);

// ============================================================================
// üìä CHARGEMENT DES DONN√âES
// ============================================================================

let geojsonData = null;
let arrondissementLayers = [];
let binomeLayers = [];
const arrondissementVisibility = {};

// ‚≠ê 1. CHARGER LE GEOJSON DES ARRONDISSEMENTS
fetch('{% static "core/data/arrondissements.geojson" %}')
    .then(response => response.json())
    .then(geojson => {
        console.log('GeoJSON charg√©:', geojson.features.length, 'arrondissements');
        geojsonData = geojson;
        
        // Cr√©er les layers d'arrondissements
        geojson.features.forEach((feature, index) => {
            const nom = feature.properties.nom;
            const arr = feature.properties.codes_postaux;
            const color = colors[(arr - 1) % colors.length];
            
            const layer = L.geoJSON(feature, {
                style: {
                    color: '#333333',
                    weight: 2,
                    opacity: 0.8,
                    fillColor: color,
                    fillOpacity: 0.25
                }
            }).addTo(map);
            
            layer.bindPopup(`
                <div class="info-popup">
                    <h4>${nom}</h4>
                    <p><strong>Code postal:</strong> ${arr}</p>
                </div>
            `);
            
            arrondissementLayers.push({
                index: index,
                nom: nom,
                layer: layer,
                arrondissement: arr
            });
            
            arrondissementVisibility[index] = true;
        });
        
        // Cr√©er le contr√¥le de filtrage
        creerControleFiltre();
        
        // ‚≠ê 2. CHARGER LES BIN√îMES (apr√®s avoir les arrondissements)
        return fetch('{% url "core:api_binomes" %}');
    })
    .then(response => response.json())
    .then(data => {
        console.log(`${data.count} bin√¥mes charg√©s`);
        
        data.binomes.forEach(binome => {
            const eleve = binome.eleve;
            const benevole = binome.benevole;
            
            // Trouver l'arrondissement de l'√©l√®ve
            const eleveArrIndex = trouverArrondissement(eleve.latitude, eleve.longitude);
            const couleurEleve = markerColors[eleveArrIndex % markerColors.length];
            
            // Trouver l'arrondissement du b√©n√©vole
            const benevoleArrIndex = trouverArrondissement(benevole.latitude, benevole.longitude);
            const couleurBenevole = markerColors[benevoleArrIndex % markerColors.length];
            
            // Ligne de connexion
            const polyline = L.polyline(
                [[eleve.latitude, eleve.longitude], [benevole.latitude, benevole.longitude]],
                {
                    color: '#000000',
                    weight: 2,
                    opacity: 0.6,
                    dashArray: '5, 5'
                }
            ).addTo(map);
            
            // Marqueur √©l√®ve
            const markerEleve = L.circleMarker([eleve.latitude, eleve.longitude], {
                radius: 8,
                fillColor: couleurEleve,
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(map);
            
            markerEleve.bindPopup(`
                <div class="info-popup">
                    <h4>üë®‚Äçüéì ${eleve.prenom} ${eleve.nom}</h4>
                    <p><strong>Classe:</strong> ${eleve.classe}</p>
                    <p><strong>B√©n√©vole:</strong> ${benevole.prenom} ${benevole.nom}</p>
                </div>
            `);
            
            // Marqueur b√©n√©vole
            const markerBenevole = L.circleMarker([benevole.latitude, benevole.longitude], {
                radius: 8,
                fillColor: couleurBenevole,
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(map);
            
            markerBenevole.bindPopup(`
                <div class="info-popup">
                    <h4>üéì ${benevole.prenom} ${benevole.nom}</h4>
                    <p><strong>√âl√®ve:</strong> ${eleve.prenom} ${eleve.nom}</p>
                </div>
            `);
            
            // Stocker le bin√¥me
            binomeLayers.push({
                eleveArrIndex: eleveArrIndex,
                benevoleArrIndex: benevoleArrIndex,
                polyline: polyline,
                markerEleve: markerEleve,
                markerBenevole: markerBenevole
            });
        });
        
        // Ajuster la vue
        if (data.binomes.length > 0) {
            const bounds = [];
            data.binomes.forEach(binome => {
                bounds.push([binome.eleve.latitude, binome.eleve.longitude]);
                bounds.push([binome.benevole.latitude, binome.benevole.longitude]);
            });
            map.fitBounds(bounds, { padding: [50, 50] });
        }
    })
    .catch(error => {
        console.error('Erreur:', error);
    });

// ============================================================================
// üîç FONCTIONS UTILITAIRES
// ============================================================================

function trouverArrondissement(lat, lon) {
    if (!geojsonData || !lat || !lon) return 0;
    
    const point = turf.point([lon, lat]);
    
    for (let i = 0; i < geojsonData.features.length; i++) {
        const feature = geojsonData.features[i];
        const polygon = turf.polygon(feature.geometry.coordinates);
        
        if (turf.booleanPointInPolygon(point, polygon)) {
            return i;
        }
    }
    
    // Si pas trouv√©, trouver le plus proche
    let minDist = Infinity;
    let closest = 0;
    
    geojsonData.features.forEach((feature, idx) => {
        const centroid = turf.centroid(feature);
        const dist = turf.distance(point, centroid, { units: 'kilometers' });
        if (dist < minDist) {
            minDist = dist;
            closest = idx;
        }
    });
    
    return closest;
}

function updateBinomeVisibility() {
    binomeLayers.forEach(binome => {
        const eleveVisible = arrondissementVisibility[binome.eleveArrIndex];
        const benevoleVisible = arrondissementVisibility[binome.benevoleArrIndex];
        const shouldShow = eleveVisible && benevoleVisible;
        
        if (shouldShow) {
            map.addLayer(binome.polyline);
            map.addLayer(binome.markerEleve);
            map.addLayer(binome.markerBenevole);
        } else {
            map.removeLayer(binome.polyline);
            map.removeLayer(binome.markerEleve);
            map.removeLayer(binome.markerBenevole);
        }
    });
}

// ============================================================================
// üéõÔ∏è CONTR√îLE DE FILTRAGE
// ============================================================================

function creerControleFiltre() {
    const filterControl = L.control({ position: 'topright' });
    
    filterControl.onAdd = function() {
        const div = L.DomUtil.create('div', 'filter-control');
        div.innerHTML = '<h3>üîç Filtrer par arrondissement</h3>';
        
        geojsonData.features.forEach((feature, index) => {
            const nom = feature.properties.nom;
            const arr = feature.properties.arrondissement;
            const color = markerColors[(arr - 1) % markerColors.length];
            
            div.innerHTML += `
                <div class="filter-item">
                    <input type="checkbox" id="arr${index}" checked onchange="toggleArrondissement(${index})">
                    <label for="arr${index}">
                        <span class="filter-color" style="background-color: ${color};"></span>
                        <span>${nom}</span>
                    </label>
                </div>
            `;
        });
        
        return div;
    };
    
    filterControl.addTo(map);
}

// Fonction globale pour toggle arrondissement
window.toggleArrondissement = function(index) {
    const checkbox = document.getElementById('arr' + index);
    arrondissementVisibility[index] = checkbox.checked;
    updateBinomeVisibility();
};
</script>
{% endblock %}